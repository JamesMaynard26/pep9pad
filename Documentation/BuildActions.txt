// #  Build Actions
// This doc attempts to consolidate all actions performed when a particular button is pressed.

// ## When the `Assemble` Button is Pressed...

// In mainwindow.cpp:

if (assemble()) {
    ui->statusbar->showMessage("Assembly succeeded", 4000);
}

bool MainWindow::assemble() {
    Pep::memAddrssToAssemblerListing = &Pep::memAddrssToAssemblerListingProg;
    Pep::listingRowChecked = &Pep::listingRowCheckedProg;
    Pep::burnCount = 0;
    if (sourceCodePane->assemble()) {
        if (Pep::burnCount > 0) {
            // checking for burn count here instead of in the assembler, probably so the sourceCodePane.assemble() can be used for assembling operating systems, too.
            QString errorString = ";ERROR: .BURN not allowed in program unless installing OS.";
            sourceCodePane->appendMessageInSourceCodePaneAt(0, errorString);
            assemblerListingPane->clearAssemblerListing();
            objectCodePane->clearObjectCode();
            listingTracePane->clearListingTrace();
            ui->pepCodeTraceTab->setCurrentIndex(0); // Make source code pane visible
            return false;
        }
        
        // no .BURN in sourceCodePane
        objectCodePane->setObjectCode(sourceCodePane->getObjectCode());
        assemblerListingPane->setAssemblerListing(sourceCodePane->getAssemblerListingList());
        listingTracePane->setListingTrace(sourceCodePane->getAssemblerListingList(), sourceCodePane->getHasCheckBox());
        memoryTracePane->setMemoryTrace();
        listingTracePane->showAssemblerListing();
        
        // then some file setting things that are irrelevant for our purposes
        
        // enable format from listing and debugging
        ui->actionEdit_Format_From_Listing->setEnabled(true);
        ui->actionBuild_Start_Debugging_Source->setEnabled(true);
        
        
        // if there is no trace tag warning and at least one of the following fields in Pep is populated, show the memory trace.
        if (!Pep::traceTagWarning && !(Pep::blockSymbols.isEmpty()
                                       && Pep::equateSymbols.isEmpty()
                                       && Pep::globalStructSymbols.isEmpty()
                                       && Pep::symbolFormat.isEmpty()
                                       && Pep::symbolFormatMultiplier.isEmpty())) {
            memoryTracePane->show();
        }
        else {
            memoryTracePane->hide();
        }
        
        return true;
    }
    
    
    // if you get here, the assembly failed
    assemblerListingPane->clearAssemblerListing();
    objectCodePane->clearObjectCode();
    listingTracePane->clearListingTrace();
    ui->pepCodeTraceTab->setCurrentIndex(0); // Make source code pane visible
    return false;
}




// In sourcecodepane.h ...

private:
    QList<Code *> codeList;
    QList<int> objectCode;
    QStringList assemblerListingList;
    QStringList listingTraceList;
    QList<bool> hasCheckBox;

bool assemble();
// Pre: The source code pane contains a Pep/9 source program.
// Post: If the program assembles correctly, true is returned, and codeList is populated
// with the code objects. Otherwise false is returned and codeList is partially populated.
// Post: Pep::symbolTable is populated with values not adjusted for .BURN.
// Post: Pep::byteCount is the byte count for the object code not adjusted for .BURN.
// Post: Pep::burnCount is the number of .BURN instructions encountered in the source program.


// And in sourcecodepane.cpp...

bool SourceCodePane::assemble() {
    QString sourceLine;
    QString errorString;
    QStringList sourceCodeList;
    Code *code;
    int lineNum = 0;
    bool dotEndDetected = false;

    removeErrorMessages();
    Asm::listOfReferencedSymbols.clear();
    Asm::listOfReferencedSymbolLineNums.clear();
    Pep::memAddrssToAssemblerListing->clear();
    Pep::symbolTable.clear();
    Pep::adjustSymbolValueForBurn.clear();
    Pep::symbolFormat.clear();
    Pep::symbolFormatMultiplier.clear();;
    Pep::symbolTraceList.clear(); // Does this clear the lists within the map?
    Pep::globalStructSymbols.clear();
    Pep::blockSymbols.clear();
    Pep::equateSymbols.clear();
    // delete all of codeList
    while (!codeList.isEmpty()) {
        delete codeList.takeFirst();
    }
    QString sourceCode = ui->textEdit->toPlainText();
    sourceCodeList = sourceCode.split('\n');
    Pep::byteCount = 0;
    Pep::burnCount = 0;
    
    // go through the [String] representation of the source code, calling Asm.processSourceLine on each one.
    while (lineNum < sourceCodeList.size() && !dotEndDetected) {
        sourceLine = sourceCodeList[lineNum];
        if (!Asm::processSourceLine(sourceLine, lineNum, code, errorString, dotEndDetected)) {
            appendMessageInSourceCodePaneAt(lineNum, errorString);
            return false;
        }
        codeList.append(code);
        lineNum++;
    }
    
    // check for .end
    if (!dotEndDetected) {
        errorString = ";ERROR: Missing .END sentinel.";
        appendMessageInSourceCodePaneAt(0, errorString);
        return false;
    }
    
    // check size
    if (Pep::byteCount > 65535) {
        errorString = ";ERROR: Object code size too large to fit into memory.";
        appendMessageInSourceCodePaneAt(0, errorString);
        return false;
    }
    
    // check for unused symbols
    for (int i = 0; i < Asm::listOfReferencedSymbols.length(); i++) {
        if (!Pep::symbolTable.contains(Asm::listOfReferencedSymbols[i])
                && !(Asm::listOfReferencedSymbols[i] == "charIn")
                && !(Asm::listOfReferencedSymbols[i] == "charOut")) {
            errorString = ";ERROR: Symbol " + Asm::listOfReferencedSymbols[i] + " is used but not defined.";
            appendMessageInSourceCodePaneAt(Asm::listOfReferencedSymbolLineNums[i], errorString);
            return false;
        }
    }
    // check for format trace tags
    Pep::traceTagWarning = false;
    for (int i = 0; i < codeList.size(); i++) {
        if (!codeList[i]->processFormatTraceTags(lineNum, errorString)) {
            appendMessageInSourceCodePaneAt(lineNum, errorString);
            Pep::traceTagWarning = true;
        }
    }
    
    // check for symbol trace tags
    if (!Pep::traceTagWarning && !(Pep::blockSymbols.isEmpty() && Pep::equateSymbols.isEmpty())) {
        for (int i = 0; i < codeList.size(); i++) {
            if (!codeList[i]->processSymbolTraceTags(lineNum, errorString)) {
                appendMessageInSourceCodePaneAt(lineNum, errorString);
                Pep::traceTagWarning = true;
            }
        }
    }
    return true;
}


Thoughts about the assemble routine:
* What is Pep?  
* Asm appears to be the parser/assembler
* The sourcecodepane does way more than the ASM_SourceViewController should.
    
Alternative: 
* One model for the source, object, and listing as PLAIN TEXT, provides interaction with fs (save, load, fsState, etc.)
    * Closest model to the user
    * The source, object, and listing VCs push/pull updates to/from this model
    * We could call this the ProjectModel
    * Could move fs interaction to another model, but that might be overkill
* One model for the source, object, and listing as ARRAYS of Code, Int, and String objects, respectively.
    * This handles the assembler side of things
    * combine SourceCodePane::assemble() and Asm::assemble()






