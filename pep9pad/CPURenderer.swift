//
//  CPURenderer.swift
//  Pep9Pad
//
//  Created by Warford on 2/20/17.
//  Copyright Â© 2017 Pepperdine. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class CPURenderer: NSObject {

    //// Drawing Methods

    public dynamic class func drawPep9CPUIPad97(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 768, height: 1024), resizing: ResizingBehavior = .center) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 768, height: 1024), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 768, y: resizedFrame.height / 1024)


        //// Color Declarations
        let color3 = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
        let initial = UIColor(red: 0.977, green: 0.836, blue: 0.004, alpha: 1.000)
        let initial2 = UIColor(red: 0.822, green: 0.693, blue: 0.461, alpha: 0.726)
        let initial3 = UIColor(red: 0.759, green: 0.920, blue: 0.002, alpha: 1.000)
        let color2 = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)
        var color2HueComponent: CGFloat = 1
        var color2SaturationComponent: CGFloat = 1
        var color2BrightnessComponent: CGFloat = 1
        color2.getHue(&color2HueComponent, saturation: &color2SaturationComponent, brightness: &color2BrightnessComponent, alpha: nil)

        let pointerColors = UIColor(hue: color2HueComponent, saturation: color2SaturationComponent, brightness: 0.5, alpha: color2.cgColor.alpha)
        let aLUColor = UIColor(red: 0.758, green: 0.814, blue: 0.983, alpha: 1.000)
        let color7 = UIColor(red: 0.325, green: 0.546, blue: 0.914, alpha: 1.000)

        //// CMux Pointer Drawing
        let cMuxPointerPath = UIBezierPath()
        cMuxPointerPath.move(to: CGPoint(x: 612.17, y: 627))
        cMuxPointerPath.addCurve(to: CGPoint(x: 667.5, y: 627), controlPoint1: CGPoint(x: 619.39, y: 627), controlPoint2: CGPoint(x: 667.5, y: 627))
        cMuxPointerPath.addLine(to: CGPoint(x: 612.17, y: 627))
        cMuxPointerPath.close()
        cMuxPointerPath.move(to: CGPoint(x: 335.5, y: 657.77))
        cMuxPointerPath.addLine(to: CGPoint(x: 331, y: 655.39))
        cMuxPointerPath.addLine(to: CGPoint(x: 335.5, y: 665.5))
        cMuxPointerPath.addLine(to: CGPoint(x: 340, y: 655.39))
        cMuxPointerPath.addLine(to: CGPoint(x: 335.5, y: 657.77))
        cMuxPointerPath.close()
        cMuxPointerPath.move(to: CGPoint(x: 335.5, y: 657.83))
        cMuxPointerPath.addCurve(to: CGPoint(x: 335.5, y: 627.5), controlPoint1: CGPoint(x: 335.5, y: 650.61), controlPoint2: CGPoint(x: 335.5, y: 627.5))
        cMuxPointerPath.addLine(to: CGPoint(x: 335.5, y: 657.83))
        cMuxPointerPath.close()
        cMuxPointerPath.move(to: CGPoint(x: 612.5, y: 627))
        cMuxPointerPath.addLine(to: CGPoint(x: 407.5, y: 628))
        cMuxPointerPath.addLine(to: CGPoint(x: 612.5, y: 627))
        cMuxPointerPath.close()
        cMuxPointerPath.move(to: CGPoint(x: 407.5, y: 628))
        cMuxPointerPath.addLine(to: CGPoint(x: 383.5, y: 628))
        cMuxPointerPath.move(to: CGPoint(x: 335.5, y: 628))
        cMuxPointerPath.addLine(to: CGPoint(x: 363.5, y: 628))
        pointerColors.setFill()
        cMuxPointerPath.fill()
        pointerColors.setStroke()
        cMuxPointerPath.lineWidth = 1
        cMuxPointerPath.stroke()


        //// AMux Pointer Drawing
        let aMuxPointerPath = UIBezierPath()
        aMuxPointerPath.move(to: CGPoint(x: 506.23, y: 545))
        aMuxPointerPath.addLine(to: CGPoint(x: 508.61, y: 540.5))
        aMuxPointerPath.addLine(to: CGPoint(x: 498.5, y: 545))
        aMuxPointerPath.addLine(to: CGPoint(x: 508.61, y: 549.5))
        aMuxPointerPath.addLine(to: CGPoint(x: 506.23, y: 545))
        aMuxPointerPath.close()
        aMuxPointerPath.move(to: CGPoint(x: 507.17, y: 545))
        aMuxPointerPath.addCurve(to: CGPoint(x: 667.5, y: 545), controlPoint1: CGPoint(x: 514.39, y: 545), controlPoint2: CGPoint(x: 667.5, y: 545))
        pointerColors.setFill()
        aMuxPointerPath.fill()
        pointerColors.setStroke()
        aMuxPointerPath.lineWidth = 1
        aMuxPointerPath.lineCapStyle = .square
        aMuxPointerPath.stroke()


        //// MARCk Drawing
        let mARCkPath = UIBezierPath()
        mARCkPath.move(to: CGPoint(x: 268.17, y: 263))
        mARCkPath.addCurve(to: CGPoint(x: 667.5, y: 263), controlPoint1: CGPoint(x: 275.39, y: 263), controlPoint2: CGPoint(x: 667.5, y: 263))
        mARCkPath.addLine(to: CGPoint(x: 268.17, y: 263))
        mARCkPath.close()
        mARCkPath.move(to: CGPoint(x: 268.1, y: 235.04))
        mARCkPath.addLine(to: CGPoint(x: 272.6, y: 237.06))
        mARCkPath.addLine(to: CGPoint(x: 268.1, y: 228.5))
        mARCkPath.addLine(to: CGPoint(x: 263.6, y: 237.06))
        mARCkPath.addLine(to: CGPoint(x: 268.1, y: 235.04))
        mARCkPath.close()
        mARCkPath.move(to: CGPoint(x: 268.1, y: 234.83))
        mARCkPath.addCurve(to: CGPoint(x: 268.1, y: 260.5), controlPoint1: CGPoint(x: 268.1, y: 240.94), controlPoint2: CGPoint(x: 268.1, y: 260.5))
        mARCkPath.addLine(to: CGPoint(x: 268.1, y: 234.83))
        mARCkPath.close()
        mARCkPath.move(to: CGPoint(x: 270.3, y: 262.75))
        mARCkPath.addCurve(to: CGPoint(x: 268.05, y: 265), controlPoint1: CGPoint(x: 270.3, y: 263.99), controlPoint2: CGPoint(x: 269.29, y: 265))
        mARCkPath.addCurve(to: CGPoint(x: 265.8, y: 262.75), controlPoint1: CGPoint(x: 266.81, y: 265), controlPoint2: CGPoint(x: 265.8, y: 263.99))
        mARCkPath.addCurve(to: CGPoint(x: 268.05, y: 260.5), controlPoint1: CGPoint(x: 265.8, y: 261.51), controlPoint2: CGPoint(x: 266.81, y: 260.5))
        mARCkPath.addCurve(to: CGPoint(x: 270.3, y: 262.75), controlPoint1: CGPoint(x: 269.29, y: 260.5), controlPoint2: CGPoint(x: 270.3, y: 261.51))
        mARCkPath.close()
        mARCkPath.move(to: CGPoint(x: 268.1, y: 289.96))
        mARCkPath.addLine(to: CGPoint(x: 272.6, y: 287.94))
        mARCkPath.addLine(to: CGPoint(x: 268.1, y: 296.5))
        mARCkPath.addLine(to: CGPoint(x: 263.6, y: 287.94))
        mARCkPath.addLine(to: CGPoint(x: 268.1, y: 289.96))
        mARCkPath.close()
        mARCkPath.move(to: CGPoint(x: 268.1, y: 290.17))
        mARCkPath.addCurve(to: CGPoint(x: 268.1, y: 264.5), controlPoint1: CGPoint(x: 268.1, y: 284.06), controlPoint2: CGPoint(x: 268.1, y: 264.5))
        mARCkPath.addLine(to: CGPoint(x: 268.1, y: 290.17))
        mARCkPath.close()
        pointerColors.setFill()
        mARCkPath.fill()
        pointerColors.setStroke()
        mARCkPath.lineWidth = 1
        mARCkPath.stroke()


        //// MDRCk Drawing
        let mDRCkPath = UIBezierPath()
        mDRCkPath.move(to: CGPoint(x: 242, y: 409))
        mDRCkPath.addCurve(to: CGPoint(x: 667.5, y: 409), controlPoint1: CGPoint(x: 249.22, y: 409), controlPoint2: CGPoint(x: 667.5, y: 409))
        mDRCkPath.addLine(to: CGPoint(x: 242, y: 409))
        mDRCkPath.close()
        mDRCkPath.move(to: CGPoint(x: 242, y: 429.77))
        mDRCkPath.addLine(to: CGPoint(x: 237.5, y: 427.39))
        mDRCkPath.addLine(to: CGPoint(x: 242, y: 437.5))
        mDRCkPath.addLine(to: CGPoint(x: 246.5, y: 427.39))
        mDRCkPath.addLine(to: CGPoint(x: 242, y: 429.77))
        mDRCkPath.close()
        mDRCkPath.move(to: CGPoint(x: 242, y: 429.83))
        mDRCkPath.addCurve(to: CGPoint(x: 242, y: 408.5), controlPoint1: CGPoint(x: 242, y: 422.61), controlPoint2: CGPoint(x: 242, y: 408.5))
        mDRCkPath.addLine(to: CGPoint(x: 242, y: 429.83))
        mDRCkPath.close()
        pointerColors.setFill()
        mDRCkPath.fill()
        pointerColors.setStroke()
        mDRCkPath.lineWidth = 1
        mDRCkPath.stroke()


        //// MDRMux Pointer Drawing
        let mDRMuxPointerPath = UIBezierPath()
        mDRMuxPointerPath.move(to: CGPoint(x: 303.23, y: 515))
        mDRMuxPointerPath.addLine(to: CGPoint(x: 305.61, y: 510.5))
        mDRMuxPointerPath.addLine(to: CGPoint(x: 295.5, y: 515))
        mDRMuxPointerPath.addLine(to: CGPoint(x: 305.61, y: 519.5))
        mDRMuxPointerPath.addLine(to: CGPoint(x: 303.23, y: 515))
        mDRMuxPointerPath.close()
        mDRMuxPointerPath.move(to: CGPoint(x: 303.17, y: 515))
        mDRMuxPointerPath.addCurve(to: CGPoint(x: 334.5, y: 515), controlPoint1: CGPoint(x: 310.39, y: 515), controlPoint2: CGPoint(x: 334.5, y: 515))
        mDRMuxPointerPath.addLine(to: CGPoint(x: 303.17, y: 515))
        mDRMuxPointerPath.close()
        mDRMuxPointerPath.move(to: CGPoint(x: 334.5, y: 569.5))
        mDRMuxPointerPath.addLine(to: CGPoint(x: 334.5, y: 514.5))
        mDRMuxPointerPath.addLine(to: CGPoint(x: 334.5, y: 569.5))
        mDRMuxPointerPath.close()
        mDRMuxPointerPath.move(to: CGPoint(x: 667.5, y: 569.5))
        mDRMuxPointerPath.addLine(to: CGPoint(x: 334, y: 569.5))
        mDRMuxPointerPath.addLine(to: CGPoint(x: 667.5, y: 569.5))
        mDRMuxPointerPath.close()
        pointerColors.setFill()
        mDRMuxPointerPath.fill()
        pointerColors.setStroke()
        mDRMuxPointerPath.lineWidth = 1
        mDRMuxPointerPath.stroke()


        //// MDRMux Drawing
        let mDRMuxPath = UIBezierPath(rect: CGRect(x: 192.5, y: 502.5, width: 99, height: 26))
        UIColor.black.setStroke()
        mDRMuxPath.lineWidth = 1
        mDRMuxPath.stroke()


        //// BBus Drawing
        let bBusPath = UIBezierPath()
        bBusPath.move(to: CGPoint(x: 554, y: 151))
        bBusPath.addLine(to: CGPoint(x: 554, y: 200))
        bBusPath.addLine(to: CGPoint(x: 313, y: 200))
        bBusPath.addLine(to: CGPoint(x: 313, y: 190))
        bBusPath.addLine(to: CGPoint(x: 295.5, y: 210))
        bBusPath.addLine(to: CGPoint(x: 313, y: 230))
        bBusPath.addLine(to: CGPoint(x: 313, y: 220))
        bBusPath.addLine(to: CGPoint(x: 554, y: 220))
        bBusPath.addLine(to: CGPoint(x: 554, y: 584))
        bBusPath.addLine(to: CGPoint(x: 544, y: 584))
        bBusPath.addLine(to: CGPoint(x: 564, y: 606.5))
        bBusPath.addLine(to: CGPoint(x: 584, y: 584))
        bBusPath.addLine(to: CGPoint(x: 574, y: 584))
        bBusPath.addLine(to: CGPoint(x: 574, y: 151))
        color3.setFill()
        bBusPath.fill()
        UIColor.black.setStroke()
        bBusPath.lineWidth = 1
        bBusPath.stroke()


        //// RegisterBank Drawing
        let registerBankPath = UIBezierPath(rect: CGRect(x: 22.5, y: 25.5, width: 600, height: 125))
        initial2.setFill()
        registerBankPath.fill()
        UIColor.black.setStroke()
        registerBankPath.lineWidth = 1
        registerBankPath.lineCapStyle = .square
        registerBankPath.stroke()


        //// MARB Drawing
        let mARBPath = UIBezierPath(rect: CGRect(x: 192.5, y: 197.5, width: 99, height: 26))
        initial2.setFill()
        mARBPath.fill()
        UIColor.black.setStroke()
        mARBPath.lineWidth = 1
        mARBPath.stroke()


        //// DataOut Drawing
        let dataOutPath = UIBezierPath(rect: CGRect(x: 192.5, y: 441.5, width: 99, height: 26))
        UIColor.black.setStroke()
        dataOutPath.lineWidth = 1
        dataOutPath.stroke()


        //// MARA Drawing
        let mARAPath = UIBezierPath(rect: CGRect(x: 192.5, y: 300.5, width: 99, height: 24))
        initial2.setFill()
        mARAPath.fill()
        UIColor.black.setStroke()
        mARAPath.lineWidth = 1
        mARAPath.stroke()


        //// MAR to Bus Drawing
        let mARToBusPath = UIBezierPath()
        mARToBusPath.move(to: CGPoint(x: 251, y: 300.5))
        mARToBusPath.addLine(to: CGPoint(x: 251, y: 223.5))
        mARToBusPath.addLine(to: CGPoint(x: 231, y: 223.5))
        mARToBusPath.addLine(to: CGPoint(x: 231, y: 247))
        mARToBusPath.addLine(to: CGPoint(x: 114.4, y: 247))
        mARToBusPath.addLine(to: CGPoint(x: 114.4, y: 237))
        mARToBusPath.addLine(to: CGPoint(x: 95.5, y: 262))
        mARToBusPath.addLine(to: CGPoint(x: 114.4, y: 287))
        mARToBusPath.addLine(to: CGPoint(x: 114.4, y: 277))
        mARToBusPath.addLine(to: CGPoint(x: 231, y: 277))
        mARToBusPath.addLine(to: CGPoint(x: 231, y: 300.5))
        mARToBusPath.addLine(to: CGPoint(x: 251, y: 300.5))
        mARToBusPath.close()
        initial.setFill()
        mARToBusPath.fill()
        UIColor.black.setStroke()
        mARToBusPath.lineWidth = 1
        mARToBusPath.stroke()


        //// System Bus Drawing
        let systemBusPath = UIBezierPath(rect: CGRect(x: 69.5, y: 210.5, width: 24, height: 801))
        UIColor.black.setStroke()
        systemBusPath.lineWidth = 1
        systemBusPath.stroke()


        //// System Bus 2 Drawing
        let systemBus2Path = UIBezierPath(rect: CGRect(x: 94, y: 434.5, width: 14.5, height: 577))
        pointerColors.setStroke()
        systemBus2Path.lineWidth = 1
        systemBus2Path.stroke()


        //// AMux Drawing
        let aMuxPath = UIBezierPath(rect: CGRect(x: 395.5, y: 532.5, width: 99, height: 26))
        UIColor.black.setStroke()
        aMuxPath.lineWidth = 1
        aMuxPath.stroke()


        //// ABus Drawing
        let aBusPath = UIBezierPath()
        aBusPath.move(to: CGPoint(x: 465, y: 151))
        aBusPath.addLine(to: CGPoint(x: 465, y: 302))
        aBusPath.addLine(to: CGPoint(x: 313, y: 302))
        aBusPath.addLine(to: CGPoint(x: 313, y: 292))
        aBusPath.addLine(to: CGPoint(x: 295.5, y: 312))
        aBusPath.addLine(to: CGPoint(x: 313, y: 332))
        aBusPath.addLine(to: CGPoint(x: 313, y: 322))
        aBusPath.addLine(to: CGPoint(x: 465, y: 322))
        aBusPath.addLine(to: CGPoint(x: 465, y: 505))
        aBusPath.addLine(to: CGPoint(x: 455, y: 505))
        aBusPath.addLine(to: CGPoint(x: 475, y: 527.5))
        aBusPath.addLine(to: CGPoint(x: 495, y: 505))
        aBusPath.addLine(to: CGPoint(x: 485, y: 505))
        aBusPath.addLine(to: CGPoint(x: 485, y: 151))
        UIColor.white.setFill()
        aBusPath.fill()
        UIColor.black.setStroke()
        aBusPath.lineWidth = 1
        aBusPath.stroke()


        //// AMux to ALU Drawing
        let aMuxToALUPath = UIBezierPath()
        aMuxToALUPath.move(to: CGPoint(x: 435, y: 559))
        aMuxToALUPath.addLine(to: CGPoint(x: 435, y: 583))
        aMuxToALUPath.addLine(to: CGPoint(x: 425, y: 583))
        aMuxToALUPath.addLine(to: CGPoint(x: 445.5, y: 606.5))
        aMuxToALUPath.addLine(to: CGPoint(x: 465, y: 583))
        aMuxToALUPath.addLine(to: CGPoint(x: 455, y: 583))
        aMuxToALUPath.addLine(to: CGPoint(x: 455, y: 558.84))
        color3.setFill()
        aMuxToALUPath.fill()
        UIColor.black.setStroke()
        aMuxToALUPath.lineWidth = 1
        aMuxToALUPath.stroke()


        //// Addr Drawing
        let addrPath = UIBezierPath()
        addrPath.move(to: CGPoint(x: 70, y: 559))
        addrPath.addLine(to: CGPoint(x: 43, y: 559))
        addrPath.addLine(to: CGPoint(x: 43, y: 549))
        addrPath.addLine(to: CGPoint(x: 25.5, y: 575))
        addrPath.addLine(to: CGPoint(x: 43, y: 601))
        addrPath.addLine(to: CGPoint(x: 43, y: 591))
        addrPath.addLine(to: CGPoint(x: 70, y: 591))
        UIColor.black.setStroke()
        addrPath.lineWidth = 1
        addrPath.stroke()


        //// CMux Drawing
        let cMuxPath = UIBezierPath(rect: CGRect(x: 323.5, y: 668.5, width: 99, height: 26))
        UIColor.black.setStroke()
        cMuxPath.lineWidth = 1
        cMuxPath.stroke()


        //// CSMux Drawing
        let cSMuxPath = UIBezierPath(rect: CGRect(x: 572.5, y: 700.5, width: 99, height: 26))
        UIColor.black.setStroke()
        cSMuxPath.lineWidth = 1
        cSMuxPath.stroke()


        //// MDRMux Out Drawing
        context.saveGState()
        context.translateBy(x: 262, y: 517.84)
        context.rotate(by: -180 * CGFloat.pi/180)

        let mDRMuxOutPath = UIBezierPath()
        mDRMuxOutPath.move(to: CGPoint(x: 10, y: 15))
        mDRMuxOutPath.addLine(to: CGPoint(x: 10, y: 24.16))
        mDRMuxOutPath.addLine(to: CGPoint(x: 0, y: 24.16))
        mDRMuxOutPath.addLine(to: CGPoint(x: 20.5, y: 47.66))
        mDRMuxOutPath.addLine(to: CGPoint(x: 40, y: 24.16))
        mDRMuxOutPath.addLine(to: CGPoint(x: 30, y: 24.16))
        mDRMuxOutPath.addLine(to: CGPoint(x: 30, y: 15))
        UIColor.black.setStroke()
        mDRMuxOutPath.lineWidth = 1
        mDRMuxOutPath.stroke()

        context.restoreGState()


        //// Data line Drawing
        let dataLinePath = UIBezierPath()
        dataLinePath.move(to: CGPoint(x: 52.91, y: 617.5))
        dataLinePath.addLine(to: CGPoint(x: 69.5, y: 635.61))
        dataLinePath.addLine(to: CGPoint(x: 52.91, y: 652.84))
        dataLinePath.addLine(to: CGPoint(x: 52.91, y: 644.01))
        dataLinePath.addLine(to: CGPoint(x: 42.09, y: 644.01))
        dataLinePath.addLine(to: CGPoint(x: 42.09, y: 652.84))
        dataLinePath.addLine(to: CGPoint(x: 25.5, y: 635.61))
        dataLinePath.addLine(to: CGPoint(x: 42.09, y: 617.5))
        dataLinePath.addLine(to: CGPoint(x: 42.09, y: 626.34))
        dataLinePath.addLine(to: CGPoint(x: 52.91, y: 626.34))
        dataLinePath.addLine(to: CGPoint(x: 52.91, y: 617.5))
        dataLinePath.addLine(to: CGPoint(x: 52.91, y: 617.5))
        dataLinePath.close()
        color3.setFill()
        dataLinePath.fill()
        UIColor.black.setStroke()
        dataLinePath.lineWidth = 1
        dataLinePath.stroke()


        //// AMux Input Drawing
        let aMuxInputPath = UIBezierPath()
        aMuxInputPath.move(to: CGPoint(x: 426.5, y: 445))
        aMuxInputPath.addLine(to: CGPoint(x: 291.5, y: 444.5))
        aMuxInputPath.addLine(to: CGPoint(x: 291.5, y: 465))
        aMuxInputPath.addLine(to: CGPoint(x: 406, y: 465))
        aMuxInputPath.addLine(to: CGPoint(x: 406, y: 504.5))
        aMuxInputPath.addLine(to: CGPoint(x: 396, y: 504.5))
        aMuxInputPath.addLine(to: CGPoint(x: 416, y: 527))
        aMuxInputPath.addLine(to: CGPoint(x: 436, y: 504.5))
        aMuxInputPath.addLine(to: CGPoint(x: 426, y: 504.5))
        aMuxInputPath.addLine(to: CGPoint(x: 426, y: 444.63))
        initial.setFill()
        aMuxInputPath.fill()
        UIColor.black.setStroke()
        aMuxInputPath.lineWidth = 1
        aMuxInputPath.stroke()


        //// MDRMux Out 2 Drawing
        context.saveGState()
        context.translateBy(x: 193, y: 434.84)
        context.rotate(by: 90 * CGFloat.pi/180)

        let mDRMuxOut2Path = UIBezierPath()
        mDRMuxOut2Path.move(to: CGPoint(x: 9.66, y: 1))
        mDRMuxOut2Path.addLine(to: CGPoint(x: 10, y: 59.16))
        mDRMuxOut2Path.addLine(to: CGPoint(x: 0, y: 59.16))
        mDRMuxOut2Path.addLine(to: CGPoint(x: 20.5, y: 82.66))
        mDRMuxOut2Path.addLine(to: CGPoint(x: 40, y: 59.16))
        mDRMuxOut2Path.addLine(to: CGPoint(x: 30, y: 59.16))
        mDRMuxOut2Path.addLine(to: CGPoint(x: 29.66, y: 1))
        initial3.setFill()
        mDRMuxOut2Path.fill()
        UIColor.black.setStroke()
        mDRMuxOut2Path.lineWidth = 1
        mDRMuxOut2Path.stroke()

        context.restoreGState()


        //// AndZ Drawing
        let andZPath = UIBezierPath(rect: CGRect(x: 545.5, y: 892.5, width: 57, height: 26))
        UIColor.black.setStroke()
        andZPath.lineWidth = 1
        andZPath.stroke()


        //// SysBus to MDRMux Drawing
        let sysBusToMDRMuxPath = UIBezierPath()
        sysBusToMDRMuxPath.move(to: CGPoint(x: 225.5, y: 603.5))
        sysBusToMDRMuxPath.addLine(to: CGPoint(x: 108, y: 604))
        sysBusToMDRMuxPath.move(to: CGPoint(x: 108.5, y: 583.5))
        sysBusToMDRMuxPath.addLine(to: CGPoint(x: 205, y: 583.5))
        sysBusToMDRMuxPath.addLine(to: CGPoint(x: 205, y: 555))
        sysBusToMDRMuxPath.addLine(to: CGPoint(x: 195, y: 555))
        sysBusToMDRMuxPath.addLine(to: CGPoint(x: 215, y: 532.5))
        sysBusToMDRMuxPath.addLine(to: CGPoint(x: 235, y: 555))
        sysBusToMDRMuxPath.addLine(to: CGPoint(x: 225, y: 555))
        sysBusToMDRMuxPath.addLine(to: CGPoint(x: 225, y: 603.87))
        UIColor.white.setFill()
        sysBusToMDRMuxPath.fill()
        UIColor.black.setStroke()
        sysBusToMDRMuxPath.lineWidth = 1
        sysBusToMDRMuxPath.stroke()


        //// ALU Out Drawing
        let aLUOutPath = UIBezierPath()
        aLUOutPath.move(to: CGPoint(x: 392.5, y: 749.5))
        aLUOutPath.addLine(to: CGPoint(x: 473.5, y: 750))
        aLUOutPath.addLine(to: CGPoint(x: 392.5, y: 749.5))
        aLUOutPath.close()
        aLUOutPath.move(to: CGPoint(x: 453, y: 729.5))
        aLUOutPath.addLine(to: CGPoint(x: 413, y: 729.5))
        aLUOutPath.addLine(to: CGPoint(x: 413, y: 721))
        aLUOutPath.addLine(to: CGPoint(x: 423, y: 721))
        aLUOutPath.addLine(to: CGPoint(x: 403, y: 698.5))
        aLUOutPath.addLine(to: CGPoint(x: 383, y: 721))
        aLUOutPath.addLine(to: CGPoint(x: 393, y: 721))
        aLUOutPath.addLine(to: CGPoint(x: 393, y: 749.87))
        aLUOutPath.move(to: CGPoint(x: 473, y: 749.5))
        aLUOutPath.addLine(to: CGPoint(x: 473, y: 691.5))
        aLUOutPath.addLine(to: CGPoint(x: 473, y: 749.5))
        aLUOutPath.close()
        aLUOutPath.move(to: CGPoint(x: 453, y: 730))
        aLUOutPath.addLine(to: CGPoint(x: 453, y: 691.5))
        aLUOutPath.addLine(to: CGPoint(x: 453, y: 730))
        aLUOutPath.close()
        UIColor.white.setFill()
        aLUOutPath.fill()
        UIColor.black.setStroke()
        aLUOutPath.lineWidth = 1
        aLUOutPath.stroke()


        //// LoadCk Drawing
        let loadCkPath = UIBezierPath()
        loadCkPath.move(to: CGPoint(x: 638.23, y: 50))
        loadCkPath.addLine(to: CGPoint(x: 640.61, y: 45.5))
        loadCkPath.addLine(to: CGPoint(x: 630.5, y: 50))
        loadCkPath.addLine(to: CGPoint(x: 640.61, y: 54.5))
        loadCkPath.addLine(to: CGPoint(x: 638.23, y: 50))
        loadCkPath.close()
        loadCkPath.move(to: CGPoint(x: 639.17, y: 50))
        loadCkPath.addCurve(to: CGPoint(x: 669.5, y: 50), controlPoint1: CGPoint(x: 646.39, y: 50), controlPoint2: CGPoint(x: 669.5, y: 50))
        pointerColors.setFill()
        loadCkPath.fill()
        pointerColors.setStroke()
        loadCkPath.lineWidth = 1
        loadCkPath.lineCapStyle = .square
        loadCkPath.stroke()


        //// C Drawing
        let cPath = UIBezierPath()
        cPath.move(to: CGPoint(x: 638.23, y: 75))
        cPath.addLine(to: CGPoint(x: 640.61, y: 70.5))
        cPath.addLine(to: CGPoint(x: 630.5, y: 75))
        cPath.addLine(to: CGPoint(x: 640.61, y: 79.5))
        cPath.addLine(to: CGPoint(x: 638.23, y: 75))
        cPath.close()
        cPath.move(to: CGPoint(x: 639.17, y: 75))
        cPath.addCurve(to: CGPoint(x: 669.5, y: 75), controlPoint1: CGPoint(x: 646.39, y: 75), controlPoint2: CGPoint(x: 669.5, y: 75))
        pointerColors.setFill()
        cPath.fill()
        pointerColors.setStroke()
        cPath.lineWidth = 1
        cPath.lineCapStyle = .square
        cPath.stroke()


        //// B Drawing
        let bPath = UIBezierPath()
        bPath.move(to: CGPoint(x: 638.23, y: 100))
        bPath.addLine(to: CGPoint(x: 640.61, y: 95.5))
        bPath.addLine(to: CGPoint(x: 630.5, y: 100))
        bPath.addLine(to: CGPoint(x: 640.61, y: 104.5))
        bPath.addLine(to: CGPoint(x: 638.23, y: 100))
        bPath.close()
        bPath.move(to: CGPoint(x: 639.17, y: 100))
        bPath.addCurve(to: CGPoint(x: 669.5, y: 100), controlPoint1: CGPoint(x: 646.39, y: 100), controlPoint2: CGPoint(x: 669.5, y: 100))
        pointerColors.setFill()
        bPath.fill()
        pointerColors.setStroke()
        bPath.lineWidth = 1
        bPath.lineCapStyle = .square
        bPath.stroke()


        //// A Drawing
        let aPath = UIBezierPath()
        aPath.move(to: CGPoint(x: 638.23, y: 125))
        aPath.addLine(to: CGPoint(x: 640.61, y: 120.5))
        aPath.addLine(to: CGPoint(x: 630.5, y: 125))
        aPath.addLine(to: CGPoint(x: 640.61, y: 129.5))
        aPath.addLine(to: CGPoint(x: 638.23, y: 125))
        aPath.close()
        aPath.move(to: CGPoint(x: 639.17, y: 125))
        aPath.addCurve(to: CGPoint(x: 669.5, y: 125), controlPoint1: CGPoint(x: 646.39, y: 125), controlPoint2: CGPoint(x: 669.5, y: 125))
        pointerColors.setFill()
        aPath.fill()
        pointerColors.setStroke()
        aPath.lineWidth = 1
        aPath.lineCapStyle = .square
        aPath.stroke()


        //// ALU Pointer Drawing
        let aLUPointerPath = UIBezierPath()
        aLUPointerPath.move(to: CGPoint(x: 600.23, y: 660))
        aLUPointerPath.addLine(to: CGPoint(x: 602.61, y: 655.5))
        aLUPointerPath.addLine(to: CGPoint(x: 592.5, y: 660))
        aLUPointerPath.addLine(to: CGPoint(x: 602.61, y: 664.5))
        aLUPointerPath.addLine(to: CGPoint(x: 600.23, y: 660))
        aLUPointerPath.close()
        aLUPointerPath.move(to: CGPoint(x: 601.17, y: 660))
        aLUPointerPath.addCurve(to: CGPoint(x: 667.5, y: 660), controlPoint1: CGPoint(x: 608.39, y: 660), controlPoint2: CGPoint(x: 667.5, y: 660))
        pointerColors.setFill()
        aLUPointerPath.fill()
        pointerColors.setStroke()
        aLUPointerPath.lineWidth = 1
        aLUPointerPath.lineCapStyle = .square
        aLUPointerPath.stroke()


        //// ALU Drawing
        let aLUPath = UIBezierPath()
        aLUPath.move(to: CGPoint(x: 408.5, y: 608.5))
        aLUPath.addLine(to: CGPoint(x: 482.5, y: 608.5))
        aLUPath.addLine(to: CGPoint(x: 492, y: 626.07))
        aLUPath.addLine(to: CGPoint(x: 523, y: 626.07))
        aLUPath.addLine(to: CGPoint(x: 532.5, y: 608.5))
        aLUPath.addLine(to: CGPoint(x: 606.5, y: 608.5))
        aLUPath.addLine(to: CGPoint(x: 572, y: 690.5))
        aLUPath.addLine(to: CGPoint(x: 447, y: 690.5))
        aLUPath.addLine(to: CGPoint(x: 408.5, y: 608.5))
        aLUPath.close()
        aLUColor.setFill()
        aLUPath.fill()
        color7.setStroke()
        aLUPath.lineWidth = 2
        aLUPath.stroke()


    
        
        //// CBus Drawing
        let cBusPath = UIBezierPath()
        cBusPath.move(to: CGPoint(x: 363.5, y: 668.5))
        cBusPath.addLine(to: CGPoint(x: 363.5, y: 604))
        cBusPath.addLine(to: CGPoint(x: 363.5, y: 668.5))
        cBusPath.close()
        cBusPath.move(to: CGPoint(x: 363.5, y: 584))
        cBusPath.addLine(to: CGPoint(x: 363.5, y: 175))
        cBusPath.addLine(to: CGPoint(x: 353.5, y: 175))
        cBusPath.addLine(to: CGPoint(x: 373.5, y: 152.5))
        cBusPath.addLine(to: CGPoint(x: 393.5, y: 175))
        cBusPath.addLine(to: CGPoint(x: 383.5, y: 175))
        cBusPath.addLine(to: CGPoint(x: 383.5, y: 668.5))
        cBusPath.move(to: CGPoint(x: 260.5, y: 603.5))
        cBusPath.addLine(to: CGPoint(x: 364, y: 604))
        cBusPath.addLine(to: CGPoint(x: 260.5, y: 603.5))
        cBusPath.close()
        cBusPath.move(to: CGPoint(x: 363.5, y: 583.5))
        cBusPath.addLine(to: CGPoint(x: 281, y: 583.5))
        cBusPath.addLine(to: CGPoint(x: 281, y: 555))
        cBusPath.addLine(to: CGPoint(x: 291, y: 555))
        cBusPath.addLine(to: CGPoint(x: 271, y: 532.5))
        cBusPath.addLine(to: CGPoint(x: 251, y: 555))
        cBusPath.addLine(to: CGPoint(x: 261, y: 555))
        cBusPath.addLine(to: CGPoint(x: 261, y: 603.87))
        UIColor.white.setFill()
        cBusPath.fill()
        UIColor.black.setStroke()
        cBusPath.lineWidth = 1
        cBusPath.stroke()


        //// CMux Input Drawing
        let cMuxInputPath = UIBezierPath()
        cMuxInputPath.move(to: CGPoint(x: 333.5, y: 859.5))
        cMuxInputPath.addLine(to: CGPoint(x: 414.5, y: 860))
        cMuxInputPath.addLine(to: CGPoint(x: 333.5, y: 859.5))
        cMuxInputPath.close()
        cMuxInputPath.move(to: CGPoint(x: 414.5, y: 839.5))
        cMuxInputPath.addLine(to: CGPoint(x: 354, y: 839.5))
        cMuxInputPath.addLine(to: CGPoint(x: 354, y: 721))
        cMuxInputPath.addLine(to: CGPoint(x: 364, y: 721))
        cMuxInputPath.addLine(to: CGPoint(x: 344, y: 698.5))
        cMuxInputPath.addLine(to: CGPoint(x: 324, y: 721))
        cMuxInputPath.addLine(to: CGPoint(x: 334, y: 721))
        cMuxInputPath.addLine(to: CGPoint(x: 334, y: 859.87))
        cMuxInputPath.move(to: CGPoint(x: 414.5, y: 860.5))
        cMuxInputPath.addLine(to: CGPoint(x: 414.5, y: 839))
        cMuxInputPath.addLine(to: CGPoint(x: 414.5, y: 860.5))
        cMuxInputPath.close()
        cMuxInputPath.move(to: CGPoint(x: 414.5, y: 790))
        cMuxInputPath.addLine(to: CGPoint(x: 414.5, y: 910))
        UIColor.black.setStroke()
        cMuxInputPath.lineWidth = 1
        cMuxInputPath.stroke()


        //// SCk Storage Drawing
        let sCkStoragePath = UIBezierPath(rect: CGRect(x: 648.5, y: 749.5, width: 25, height: 25))
        UIColor.black.setStroke()
        sCkStoragePath.lineWidth = 1
        sCkStoragePath.stroke()


        //// VCk Storage Drawing
        let vCkStoragePath = UIBezierPath(rect: CGRect(x: 648.5, y: 829.5, width: 25, height: 25))
        UIColor.black.setStroke()
        vCkStoragePath.lineWidth = 1
        vCkStoragePath.stroke()


        //// CCk Storage Drawing
        let cCkStoragePath = UIBezierPath(rect: CGRect(x: 648.5, y: 786.5, width: 25, height: 25))
        UIColor.black.setStroke()
        cCkStoragePath.lineWidth = 1
        cCkStoragePath.stroke()


        //// ZCk Storage Drawing
        let zCkStoragePath = UIBezierPath(rect: CGRect(x: 648.5, y: 892.5, width: 25, height: 25))
        UIColor.black.setStroke()
        zCkStoragePath.lineWidth = 1
        zCkStoragePath.stroke()


        //// NCk Storage Drawing
        let nCkStoragePath = UIBezierPath(rect: CGRect(x: 648.5, y: 948.5, width: 25, height: 25))
        UIColor.black.setStroke()
        nCkStoragePath.lineWidth = 1
        nCkStoragePath.stroke()
        
        context.restoreGState()

    }




    @objc public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}
